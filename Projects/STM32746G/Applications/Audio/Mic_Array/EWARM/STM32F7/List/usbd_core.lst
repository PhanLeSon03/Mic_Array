###############################################################################
#
<<<<<<< HEAD
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Feb/2016  22:27:45
=======
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       19/Feb/2016  17:44:16
>>>>>>> 057df7a95ed4be7451b7a4a457af92f9cb269b3e
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_core.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_core.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_core.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_core.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_core.c
      4            * @author  MCD Application Team
      5            * @version V2.4.1
      6            * @date    19-June-2015
      7            * @brief   This file provides all the USBD core functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_core.h"
     30          
     31          /** @addtogroup STM32_USBD_DEVICE_LIBRARY
     32          * @{
     33          */
     34          
     35          
     36          /** @defgroup USBD_CORE 
     37          * @brief usbd core module
     38          * @{
     39          */ 
     40          
     41          /** @defgroup USBD_CORE_Private_TypesDefinitions
     42          * @{
     43          */ 
     44          /**
     45          * @}
     46          */ 
     47          
     48          
     49          /** @defgroup USBD_CORE_Private_Defines
     50          * @{
     51          */ 
     52          
     53          /**
     54          * @}
     55          */ 
     56          
     57          
     58          /** @defgroup USBD_CORE_Private_Macros
     59          * @{
     60          */ 
     61          /**
     62          * @}
     63          */ 
     64          
     65          
     66          
     67          
     68          /** @defgroup USBD_CORE_Private_FunctionPrototypes
     69          * @{
     70          */ 
     71          
     72          /**
     73          * @}
     74          */ 
     75          
     76          /** @defgroup USBD_CORE_Private_Variables
     77          * @{
     78          */ 
     79          
     80          /**
     81          * @}
     82          */ 
     83          
     84          /** @defgroup USBD_CORE_Private_Functions
     85          * @{
     86          */ 
     87          
     88          /**
     89          * @brief  USBD_Init
     90          *         Initializes the device stack and load the class driver
     91          * @param  pdev: device instance
     92          * @param  pdesc: Descriptor structure address
     93          * @param  id: Low level core index
     94          * @retval None
     95          */

   \                                 In section .text, align 2, keep-with-next
     96          USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
     97          {
   \                     USBD_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     98            /* Check whether the USB Host handle is valid */
     99            if(pdev == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??USBD_Init_0
    100            {
    101              USBD_ErrLog("Invalid Device handle");
    102              return USBD_FAIL; 
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE012             B.N      ??USBD_Init_1
    103            }
    104            
    105            /* Unlink previous class*/
    106            if(pdev->pClass != NULL)
   \                     ??USBD_Init_0: (+1)
   \   00000010   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??USBD_Init_2
    107            {
    108              pdev->pClass = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF8C4 0x0214      STR      R0,[R4, #+532]
    109            }
    110            
    111            /* Assign USBD Descriptors */
    112            if(pdesc != NULL)
   \                     ??USBD_Init_2: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD001             BEQ.N    ??USBD_Init_3
    113            {
    114              pdev->pDesc = pdesc;
   \   00000022   0xF8C4 0x5210      STR      R5,[R4, #+528]
    115            }
    116            
    117            /* Set Device initial State */
    118            pdev->dev_state  = USBD_STATE_DEFAULT;
   \                     ??USBD_Init_3: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF884 0x01FC      STRB     R0,[R4, #+508]
    119            pdev->id = id;
   \   0000002C   0x7026             STRB     R6,[R4, #+0]
    120            /* Initialize low level driver */
    121            USBD_LL_Init(pdev);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       USBD_LL_Init
    122            
    123            return USBD_OK; 
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??USBD_Init_1: (+1)
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    124          }
    125          
    126          /**
    127          * @brief  USBD_DeInit 
    128          *         Re-Initialize th device library
    129          * @param  pdev: device instance
    130          * @retval status: status
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
    133          {
   \                     USBD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    134            /* Set Default State */
    135            pdev->dev_state  = USBD_STATE_DEFAULT;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF884 0x01FC      STRB     R0,[R4, #+508]
    136            
    137            /* Free Class Resources */
    138            pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000014   0x6852             LDR      R2,[R2, #+4]
   \   00000016   0x4790             BLX      R2
    139            
    140              /* Stop the low level driver  */
    141            USBD_LL_Stop(pdev); 
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       USBD_LL_Stop
    142            
    143            /* Initialize low level driver */
    144            USBD_LL_DeInit(pdev);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       USBD_LL_DeInit
    145            
    146            return USBD_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    147          }
    148          
    149          
    150          /**
    151            * @brief  USBD_RegisterClass 
    152            *         Link class driver to Device Core.
    153            * @param  pDevice : Device Handle
    154            * @param  pclass: Class handle
    155            * @retval USBD Status
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
    158          {
   \                     USBD_RegisterClass: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    159            USBD_StatusTypeDef   status = USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
    160            if(pclass != 0)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??USBD_RegisterClass_0
    161            {
    162              /* link the class to the USB Device handle */
    163              pdev->pClass = pclass;
   \   00000008   0xF8C2 0x1214      STR      R1,[R2, #+532]
    164              status = USBD_OK;
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE001             B.N      ??USBD_RegisterClass_1
    165            }
    166            else
    167            {
    168              USBD_ErrLog("Invalid Class handle");
    169              status = USBD_FAIL; 
   \                     ??USBD_RegisterClass_0: (+1)
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x0018             MOVS     R0,R3
    170            }
    171            
    172            return status;
   \                     ??USBD_RegisterClass_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    173          }
    174          
    175          /**
    176            * @brief  USBD_Start 
    177            *         Start the USB Device Core.
    178            * @param  pdev: Device Handle
    179            * @retval USBD Status
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
    182          {
   \                     USBD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    183            
    184            /* Start the low level driver  */
    185            USBD_LL_Start(pdev); 
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USBD_LL_Start
    186            
    187            return USBD_OK;  
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    188          }
    189          
    190          /**
    191            * @brief  USBD_Stop 
    192            *         Stop the USB Device Core.
    193            * @param  pdev: Device Handle
    194            * @retval USBD Status
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
    197          {
   \                     USBD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    198            /* Free Class Resources */
    199            pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   00000004   0x6861             LDR      R1,[R4, #+4]
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   0000000E   0x6852             LDR      R2,[R2, #+4]
   \   00000010   0x4790             BLX      R2
    200          
    201            /* Stop the low level driver  */
    202            USBD_LL_Stop(pdev); 
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       USBD_LL_Stop
    203            
    204            return USBD_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    205          }
    206          
    207          /**
    208          * @brief  USBD_RunTestMode 
    209          *         Launch test mode process
    210          * @param  pdev: device instance
    211          * @retval status
    212          */

   \                                 In section .text, align 2, keep-with-next
    213          USBD_StatusTypeDef  USBD_RunTestMode (USBD_HandleTypeDef  *pdev) 
    214          {
   \                     USBD_RunTestMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    215            return USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    216          }
    217          
    218          
    219          /**
    220          * @brief  USBD_SetClassConfig 
    221          *        Configure device and start the interface
    222          * @param  pdev: device instance
    223          * @param  cfgidx: configuration index
    224          * @retval status
    225          */
    226          

   \                                 In section .text, align 2, keep-with-next
    227          USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
    228          {
   \                     USBD_SetClassConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    229            USBD_StatusTypeDef   ret = USBD_FAIL;
   \   00000006   0x2602             MOVS     R6,#+2
    230            
    231            if(pdev->pClass != NULL)
   \   00000008   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00A             BEQ.N    ??USBD_SetClassConfig_0
    232            {
    233              /* Set configuration  and Start the Class*/
    234              if(pdev->pClass->Init(pdev, cfgidx) == 0)
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x4790             BLX      R2
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??USBD_SetClassConfig_0
    235              {
    236                ret = USBD_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0006             MOVS     R6,R0
    237              }
    238            }
    239            return ret; 
   \                     ??USBD_SetClassConfig_0: (+1)
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    240          }
    241          
    242          /**
    243          * @brief  USBD_ClrClassConfig 
    244          *         Clear current configuration
    245          * @param  pdev: device instance
    246          * @param  cfgidx: configuration index
    247          * @retval status: USBD_StatusTypeDef
    248          */

   \                                 In section .text, align 2, keep-with-next
    249          USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
    250          {
   \                     USBD_ClrClassConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    251            /* Clear configuration  and De-initialize the Class process*/
    252            pdev->pClass->DeInit(pdev, cfgidx);  
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000010   0x6852             LDR      R2,[R2, #+4]
   \   00000012   0x4790             BLX      R2
    253            return USBD_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    254          }
    255          
    256          
    257          /**
    258          * @brief  USBD_SetupStage 
    259          *         Handle the setup stage
    260          * @param  pdev: device instance
    261          * @retval status
    262          */

   \                                 In section .text, align 2, keep-with-next
    263          USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
    264          {
   \                     USBD_LL_SetupStage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    265          
    266            USBD_ParseSetupRequest(&pdev->request, psetup);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xF514 0x7002      ADDS     R0,R4,#+520
   \   0000000C   0x.... 0x....      BL       USBD_ParseSetupRequest
    267            
    268            pdev->ep0_state = USBD_EP0_SETUP;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF8C4 0x01F4      STR      R0,[R4, #+500]
    269            pdev->ep0_data_len = pdev->request.wLength;
   \   00000016   0xF8B4 0x020E      LDRH     R0,[R4, #+526]
   \   0000001A   0xF8C4 0x01F8      STR      R0,[R4, #+504]
    270            
    271            switch (pdev->request.bmRequest & 0x1F) 
   \   0000001E   0xF894 0x0208      LDRB     R0,[R4, #+520]
   \   00000022   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD003             BEQ.N    ??USBD_LL_SetupStage_0
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD00D             BEQ.N    ??USBD_LL_SetupStage_1
   \   00000030   0xD306             BCC.N    ??USBD_LL_SetupStage_2
   \   00000032   0xE011             B.N      ??USBD_LL_SetupStage_3
    272            {
    273            case USB_REQ_RECIPIENT_DEVICE:   
    274              USBD_StdDevReq (pdev, &pdev->request);
   \                     ??USBD_LL_SetupStage_0: (+1)
   \   00000034   0xF514 0x7102      ADDS     R1,R4,#+520
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       USBD_StdDevReq
    275              break;
   \   0000003E   0xE012             B.N      ??USBD_LL_SetupStage_4
    276              
    277            case USB_REQ_RECIPIENT_INTERFACE:     
    278              USBD_StdItfReq(pdev, &pdev->request);
   \                     ??USBD_LL_SetupStage_2: (+1)
   \   00000040   0xF514 0x7102      ADDS     R1,R4,#+520
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       USBD_StdItfReq
    279              break;
   \   0000004A   0xE00C             B.N      ??USBD_LL_SetupStage_4
    280              
    281            case USB_REQ_RECIPIENT_ENDPOINT:        
    282              USBD_StdEPReq(pdev, &pdev->request);   
   \                     ??USBD_LL_SetupStage_1: (+1)
   \   0000004C   0xF514 0x7102      ADDS     R1,R4,#+520
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       USBD_StdEPReq
    283              break;
   \   00000056   0xE006             B.N      ??USBD_LL_SetupStage_4
    284              
    285            default:           
    286              USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
   \                     ??USBD_LL_SetupStage_3: (+1)
   \   00000058   0xF894 0x0208      LDRB     R0,[R4, #+520]
   \   0000005C   0xF010 0x0180      ANDS     R1,R0,#0x80
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       USBD_LL_StallEP
    287              break;
    288            }  
    289            return USBD_OK;  
   \                     ??USBD_LL_SetupStage_4: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    290          }
    291          
    292          /**
    293          * @brief  USBD_DataOutStage 
    294          *         Handle data OUT stage
    295          * @param  pdev: device instance
    296          * @param  epnum: endpoint index
    297          * @retval status
    298          */

   \                                 In section .text, align 2, keep-with-next
    299          USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
    300          {
   \                     USBD_LL_DataOutStage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    301            USBD_EndpointTypeDef    *pep;
    302            
    303            if(epnum == 0) 
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD12D             BNE.N    ??USBD_LL_DataOutStage_0
    304            {
    305              pep = &pdev->ep_out[0];
   \   0000000E   0xF514 0x7082      ADDS     R0,R4,#+260
   \   00000012   0x0007             MOVS     R7,R0
    306              
    307              if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
   \   00000014   0xF8D4 0x01F4      LDR      R0,[R4, #+500]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD136             BNE.N    ??USBD_LL_DataOutStage_1
    308              {
    309                if(pep->rem_length > pep->maxpacket)
   \   0000001C   0x68F8             LDR      R0,[R7, #+12]
   \   0000001E   0x68B9             LDR      R1,[R7, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD210             BCS.N    ??USBD_LL_DataOutStage_2
    310                {
    311                  pep->rem_length -=  pep->maxpacket;
   \   00000024   0x68B8             LDR      R0,[R7, #+8]
   \   00000026   0x68F9             LDR      R1,[R7, #+12]
   \   00000028   0x1A40             SUBS     R0,R0,R1
   \   0000002A   0x60B8             STR      R0,[R7, #+8]
    312                 
    313                  USBD_CtlContinueRx (pdev, 
    314                                      pdata,
    315                                      MIN(pep->rem_length ,pep->maxpacket));
   \   0000002C   0x68B8             LDR      R0,[R7, #+8]
   \   0000002E   0x68F9             LDR      R1,[R7, #+12]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD201             BCS.N    ??USBD_LL_DataOutStage_3
   \   00000034   0x68BA             LDR      R2,[R7, #+8]
   \   00000036   0xE000             B.N      ??USBD_LL_DataOutStage_4
   \                     ??USBD_LL_DataOutStage_3: (+1)
   \   00000038   0x68FA             LDR      R2,[R7, #+12]
   \                     ??USBD_LL_DataOutStage_4: (+1)
   \   0000003A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   0x0031             MOVS     R1,R6
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       USBD_CtlContinueRx
   \   00000044   0xE021             B.N      ??USBD_LL_DataOutStage_1
    316                }
    317                else
    318                {
    319                  if((pdev->pClass->EP0_RxReady != NULL)&&
    320                     (pdev->dev_state == USBD_STATE_CONFIGURED))
   \                     ??USBD_LL_DataOutStage_2: (+1)
   \   00000046   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   0000004A   0x6900             LDR      R0,[R0, #+16]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD008             BEQ.N    ??USBD_LL_DataOutStage_5
   \   00000050   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD104             BNE.N    ??USBD_LL_DataOutStage_5
    321                  {
    322                    pdev->pClass->EP0_RxReady(pdev); 
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0xF8D4 0x1214      LDR      R1,[R4, #+532]
   \   0000005E   0x6909             LDR      R1,[R1, #+16]
   \   00000060   0x4788             BLX      R1
    323                  }
    324                  USBD_CtlSendStatus(pdev);
   \                     ??USBD_LL_DataOutStage_5: (+1)
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       USBD_CtlSendStatus
   \   00000068   0xE00F             B.N      ??USBD_LL_DataOutStage_1
    325                }
    326              }
    327            }
    328            else if((pdev->pClass->DataOut != NULL)&&
    329                    (pdev->dev_state == USBD_STATE_CONFIGURED))
   \                     ??USBD_LL_DataOutStage_0: (+1)
   \   0000006A   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   0000006E   0x6980             LDR      R0,[R0, #+24]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD00A             BEQ.N    ??USBD_LL_DataOutStage_1
   \   00000074   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xD106             BNE.N    ??USBD_LL_DataOutStage_1
    330            {
    331              pdev->pClass->DataOut(pdev, epnum); 
   \   0000007C   0x0029             MOVS     R1,R5
   \   0000007E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000086   0x6992             LDR      R2,[R2, #+24]
   \   00000088   0x4790             BLX      R2
    332            }  
    333            return USBD_OK;
   \                     ??USBD_LL_DataOutStage_1: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    334          }
    335          
    336          /**
    337          * @brief  USBD_DataInStage 
    338          *         Handle data in stage
    339          * @param  pdev: device instance
    340          * @param  epnum: endpoint index
    341          * @retval status
    342          */

   \                                 In section .text, align 2, keep-with-next
    343          USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
    344          {
   \                     USBD_LL_DataInStage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    345            USBD_EndpointTypeDef    *pep;
    346              
    347            if(epnum == 0) 
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD157             BNE.N    ??USBD_LL_DataInStage_0
    348            {
    349              pep = &pdev->ep_in[0];
   \   0000000E   0xF114 0x0014      ADDS     R0,R4,#+20
   \   00000012   0x0007             MOVS     R7,R0
    350              
    351              if ( pdev->ep0_state == USBD_EP0_DATA_IN)
   \   00000014   0xF8D4 0x01F4      LDR      R0,[R4, #+500]
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD145             BNE.N    ??USBD_LL_DataInStage_1
    352              {
    353                if(pep->rem_length > pep->maxpacket)
   \   0000001C   0x68F8             LDR      R0,[R7, #+12]
   \   0000001E   0x68B9             LDR      R1,[R7, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD210             BCS.N    ??USBD_LL_DataInStage_2
    354                {
    355                  pep->rem_length -=  pep->maxpacket;
   \   00000024   0x68B8             LDR      R0,[R7, #+8]
   \   00000026   0x68F9             LDR      R1,[R7, #+12]
   \   00000028   0x1A40             SUBS     R0,R0,R1
   \   0000002A   0x60B8             STR      R0,[R7, #+8]
    356                  
    357                  USBD_CtlContinueSendData (pdev, 
    358                                            pdata, 
    359                                            pep->rem_length);
   \   0000002C   0x68BA             LDR      R2,[R7, #+8]
   \   0000002E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       USBD_CtlContinueSendData
    360                  
    361                  /* Prepare endpoint for premature end of transfer */
    362                  USBD_LL_PrepareReceive (pdev,
    363                                          0,
    364                                          NULL,
    365                                          0);  
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       USBD_LL_PrepareReceive
   \   00000044   0xE030             B.N      ??USBD_LL_DataInStage_1
    366                }
    367                else
    368                { /* last packet is MPS multiple, so send ZLP packet */
    369                  if((pep->total_length % pep->maxpacket == 0) &&
    370                     (pep->total_length >= pep->maxpacket) &&
    371                       (pep->total_length < pdev->ep0_data_len ))
   \                     ??USBD_LL_DataInStage_2: (+1)
   \   00000046   0x6878             LDR      R0,[R7, #+4]
   \   00000048   0x68F9             LDR      R1,[R7, #+12]
   \   0000004A   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000004E   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD117             BNE.N    ??USBD_LL_DataInStage_3
   \   00000056   0x6878             LDR      R0,[R7, #+4]
   \   00000058   0x68F9             LDR      R1,[R7, #+12]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD313             BCC.N    ??USBD_LL_DataInStage_3
   \   0000005E   0x6878             LDR      R0,[R7, #+4]
   \   00000060   0xF8D4 0x11F8      LDR      R1,[R4, #+504]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD20E             BCS.N    ??USBD_LL_DataInStage_3
    372                  {
    373                    
    374                    USBD_CtlContinueSendData(pdev , NULL, 0);
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       USBD_CtlContinueSendData
    375                    pdev->ep0_data_len = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF8C4 0x01F8      STR      R0,[R4, #+504]
    376                    
    377                  /* Prepare endpoint for premature end of transfer */
    378                  USBD_LL_PrepareReceive (pdev,
    379                                          0,
    380                                          NULL,
    381                                          0);
   \   00000078   0x2300             MOVS     R3,#+0
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       USBD_LL_PrepareReceive
   \   00000084   0xE010             B.N      ??USBD_LL_DataInStage_1
    382                  }
    383                  else
    384                  {
    385                    if((pdev->pClass->EP0_TxSent != NULL)&&
    386                       (pdev->dev_state == USBD_STATE_CONFIGURED))
   \                     ??USBD_LL_DataInStage_3: (+1)
   \   00000086   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD008             BEQ.N    ??USBD_LL_DataInStage_4
   \   00000090   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000094   0x2803             CMP      R0,#+3
   \   00000096   0xD104             BNE.N    ??USBD_LL_DataInStage_4
    387                    {
    388                      pdev->pClass->EP0_TxSent(pdev); 
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0xF8D4 0x1214      LDR      R1,[R4, #+532]
   \   0000009E   0x68C9             LDR      R1,[R1, #+12]
   \   000000A0   0x4788             BLX      R1
    389                    }          
    390                    USBD_CtlReceiveStatus(pdev);
   \                     ??USBD_LL_DataInStage_4: (+1)
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       USBD_CtlReceiveStatus
    391                  }
    392                }
    393              }
    394              if (pdev->dev_test_mode == 1)
   \                     ??USBD_LL_DataInStage_1: (+1)
   \   000000A8   0xF894 0x0200      LDRB     R0,[R4, #+512]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD116             BNE.N    ??USBD_LL_DataInStage_5
    395              {
    396                USBD_RunTestMode(pdev); 
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       USBD_RunTestMode
    397                pdev->dev_test_mode = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF884 0x0200      STRB     R0,[R4, #+512]
   \   000000BC   0xE00F             B.N      ??USBD_LL_DataInStage_5
    398              }
    399            }
    400            else if((pdev->pClass->DataIn != NULL)&& 
    401                    (pdev->dev_state == USBD_STATE_CONFIGURED))
   \                     ??USBD_LL_DataInStage_0: (+1)
   \   000000BE   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   000000C2   0x6940             LDR      R0,[R0, #+20]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD00A             BEQ.N    ??USBD_LL_DataInStage_5
   \   000000C8   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   000000CC   0x2803             CMP      R0,#+3
   \   000000CE   0xD106             BNE.N    ??USBD_LL_DataInStage_5
    402            {
    403              pdev->pClass->DataIn(pdev, epnum); 
   \   000000D0   0x0029             MOVS     R1,R5
   \   000000D2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   000000DA   0x6952             LDR      R2,[R2, #+20]
   \   000000DC   0x4790             BLX      R2
    404            }  
    405            return USBD_OK;
   \                     ??USBD_LL_DataInStage_5: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    406          }
    407          
    408          /**
    409          * @brief  USBD_LL_Reset 
    410          *         Handle Reset event
    411          * @param  pdev: device instance
    412          * @retval status
    413          */
    414          

   \                                 In section .text, align 2, keep-with-next
    415          USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
    416          {
   \                     USBD_LL_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    417            /* Open EP0 OUT */
    418            USBD_LL_OpenEP(pdev,
    419                        0x00,
    420                        USBD_EP_TYPE_CTRL,
    421                        USB_MAX_EP0_SIZE);
   \   00000004   0x2340             MOVS     R3,#+64
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       USBD_LL_OpenEP
    422            
    423            pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0xF8C4 0x0110      STR      R0,[R4, #+272]
    424            
    425            /* Open EP0 IN */
    426            USBD_LL_OpenEP(pdev,
    427                        0x80,
    428                        USBD_EP_TYPE_CTRL,
    429                        USB_MAX_EP0_SIZE);
   \   00000016   0x2340             MOVS     R3,#+64
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       USBD_LL_OpenEP
    430            
    431            pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0x6220             STR      R0,[R4, #+32]
    432            /* Upon Reset call user call back */
    433            pdev->dev_state = USBD_STATE_DEFAULT;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF884 0x01FC      STRB     R0,[R4, #+508]
    434            
    435            if (pdev->pClassData) 
   \   0000002C   0xF8D4 0x0218      LDR      R0,[R4, #+536]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD006             BEQ.N    ??USBD_LL_Reset_0
    436              pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   00000034   0x6861             LDR      R1,[R4, #+4]
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   0000003E   0x6852             LDR      R2,[R2, #+4]
   \   00000040   0x4790             BLX      R2
    437           
    438            
    439            return USBD_OK;
   \                     ??USBD_LL_Reset_0: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    440          }
    441          
    442          
    443          
    444          
    445          /**
    446          * @brief  USBD_LL_Reset 
    447          *         Handle Reset event
    448          * @param  pdev: device instance
    449          * @retval status
    450          */

   \                                 In section .text, align 2, keep-with-next
    451          USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
    452          {
   \                     USBD_LL_SetSpeed: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    453            pdev->dev_speed = speed;
   \   00000002   0x7411             STRB     R1,[R2, #+16]
    454            return USBD_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR               ;; return
    455          }
    456          
    457          /**
    458          * @brief  USBD_Suspend 
    459          *         Handle Suspend event
    460          * @param  pdev: device instance
    461          * @retval status
    462          */
    463          

   \                                 In section .text, align 2, keep-with-next
    464          USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
    465          {
   \                     USBD_LL_Suspend: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    466            pdev->dev_old_state =  pdev->dev_state;
   \   00000002   0xF891 0x01FC      LDRB     R0,[R1, #+508]
   \   00000006   0xF881 0x01FD      STRB     R0,[R1, #+509]
    467            pdev->dev_state  = USBD_STATE_SUSPENDED;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xF881 0x01FC      STRB     R0,[R1, #+508]
    468            return USBD_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    469          }
    470          
    471          /**
    472          * @brief  USBD_Resume 
    473          *         Handle Resume event
    474          * @param  pdev: device instance
    475          * @retval status
    476          */
    477          

   \                                 In section .text, align 2, keep-with-next
    478          USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
    479          {
   \                     USBD_LL_Resume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    480            pdev->dev_state = pdev->dev_old_state;  
   \   00000002   0xF891 0x01FD      LDRB     R0,[R1, #+509]
   \   00000006   0xF881 0x01FC      STRB     R0,[R1, #+508]
    481            return USBD_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    482          }
    483          
    484          /**
    485          * @brief  USBD_SOF 
    486          *         Handle SOF event
    487          * @param  pdev: device instance
    488          * @retval status
    489          */
    490          

   \                                 In section .text, align 2, keep-with-next
    491          USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
    492          {
   \                     USBD_LL_SOF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    493            if(pdev->dev_state == USBD_STATE_CONFIGURED)
   \   00000004   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD109             BNE.N    ??USBD_LL_SOF_0
    494            {
    495              if(pdev->pClass->SOF != NULL)
   \   0000000C   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   00000010   0x69C0             LDR      R0,[R0, #+28]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??USBD_LL_SOF_0
    496              {
    497                pdev->pClass->SOF(pdev);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xF8D4 0x1214      LDR      R1,[R4, #+532]
   \   0000001C   0x69C9             LDR      R1,[R1, #+28]
   \   0000001E   0x4788             BLX      R1
    498              }
    499            }
    500            return USBD_OK;
   \                     ??USBD_LL_SOF_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    501          }
    502          
    503          /**
    504          * @brief  USBD_IsoINIncomplete 
    505          *         Handle iso in incomplete event
    506          * @param  pdev: device instance
    507          * @retval status
    508          */

   \                                 In section .text, align 2, keep-with-next
    509          USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
    510          {
   \                     USBD_LL_IsoINIncomplete: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    511            return USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    512          }
    513          
    514          /**
    515          * @brief  USBD_IsoOUTIncomplete 
    516          *         Handle iso out incomplete event
    517          * @param  pdev: device instance
    518          * @retval status
    519          */

   \                                 In section .text, align 2, keep-with-next
    520          USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
    521          {
   \                     USBD_LL_IsoOUTIncomplete: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    522            return USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    523          }
    524          
    525          /**
    526          * @brief  USBD_DevConnected 
    527          *         Handle device connection event
    528          * @param  pdev: device instance
    529          * @retval status
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
    532          {
   \                     USBD_LL_DevConnected: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    533            return USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    534          }
    535          
    536          /**
    537          * @brief  USBD_DevDisconnected 
    538          *         Handle device disconnection event
    539          * @param  pdev: device instance
    540          * @retval status
    541          */

   \                                 In section .text, align 2, keep-with-next
    542          USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
    543          {
   \                     USBD_LL_DevDisconnected: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    544            /* Free Class Resources */
    545            pdev->dev_state = USBD_STATE_DEFAULT;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF884 0x01FC      STRB     R0,[R4, #+508]
    546            pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000014   0x6852             LDR      R2,[R2, #+4]
   \   00000016   0x4790             BLX      R2
    547             
    548            return USBD_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    549          }
    550          /**
    551          * @}
    552          */ 
    553          
    554          
    555          /**
    556          * @}
    557          */ 
    558          
    559          
    560          /**
    561          * @}
    562          */ 
    563          
    564          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    565          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USBD_ClrClassConfig
        16   -- Indirect call
       8   USBD_DeInit
         8   -- Indirect call
         8   -> USBD_LL_DeInit
         8   -> USBD_LL_Stop
      16   USBD_Init
        16   -> USBD_LL_Init
      24   USBD_LL_DataInStage
        24   -- Indirect call
        24   -> USBD_CtlContinueSendData
        24   -> USBD_CtlReceiveStatus
        24   -> USBD_LL_PrepareReceive
        24   -> USBD_RunTestMode
      24   USBD_LL_DataOutStage
        24   -- Indirect call
        24   -> USBD_CtlContinueRx
        24   -> USBD_CtlSendStatus
       0   USBD_LL_DevConnected
       8   USBD_LL_DevDisconnected
         8   -- Indirect call
       0   USBD_LL_IsoINIncomplete
       0   USBD_LL_IsoOUTIncomplete
       8   USBD_LL_Reset
         8   -- Indirect call
         8   -> USBD_LL_OpenEP
       0   USBD_LL_Resume
       8   USBD_LL_SOF
         8   -- Indirect call
       0   USBD_LL_SetSpeed
      16   USBD_LL_SetupStage
        16   -> USBD_LL_StallEP
        16   -> USBD_ParseSetupRequest
        16   -> USBD_StdDevReq
        16   -> USBD_StdEPReq
        16   -> USBD_StdItfReq
       0   USBD_LL_Suspend
       0   USBD_RegisterClass
       0   USBD_RunTestMode
      16   USBD_SetClassConfig
        16   -- Indirect call
       8   USBD_Start
         8   -> USBD_LL_Start
       8   USBD_Stop
         8   -- Indirect call
         8   -> USBD_LL_Stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  USBD_ClrClassConfig
      40  USBD_DeInit
      56  USBD_Init
     226  USBD_LL_DataInStage
     142  USBD_LL_DataOutStage
       6  USBD_LL_DevConnected
      28  USBD_LL_DevDisconnected
       6  USBD_LL_IsoINIncomplete
       6  USBD_LL_IsoOUTIncomplete
      70  USBD_LL_Reset
      14  USBD_LL_Resume
      36  USBD_LL_SOF
       8  USBD_LL_SetSpeed
     106  USBD_LL_SetupStage
      20  USBD_LL_Suspend
      26  USBD_RegisterClass
       6  USBD_RunTestMode
      44  USBD_SetClassConfig
      14  USBD_Start
      28  USBD_Stop

 
 906 bytes in section .text
 
 906 bytes of CODE memory

Errors: none
Warnings: none
